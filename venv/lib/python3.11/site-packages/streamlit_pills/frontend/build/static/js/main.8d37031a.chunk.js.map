{"version":3,"sources":["index.tsx"],"names":["labelDiv","document","body","appendChild","createElement","label","createTextNode","container","classList","add","Streamlit","events","addEventListener","RENDER_EVENT","event","data","detail","textContent","args","options","icons","index","clearable","childNodes","length","forEach","option","i","pill","icon_span","onclick","unselect","contains","querySelectorAll","el","remove","setComponentValue","theme","style","font","color","textColor","base","setFrameHeight","setComponentReady"],"mappings":"mJAAA,kBAEMA,EAAWC,SAASC,KAAKC,YAAYF,SAASG,cAAc,UAC5DC,EAAQL,EAASG,YAAYF,SAASK,eAAe,KACrDC,EAAYN,SAASC,KAAKC,YAAYF,SAASG,cAAc,QACnEG,EAAUC,UAAUC,IAAI,aAmFxBC,IAAUC,OAAOC,iBAAiBF,IAAUG,cA5E5C,SAAkBC,GAEhB,IAAMC,EAAQD,EAAkCE,OAEhDX,EAAMY,YAAcF,EAAKG,KAAL,MACpB,IAAIC,EAAUJ,EAAKG,KAAL,QACVE,EAAQL,EAAKG,KAAL,MACRG,EAAQN,EAAKG,KAAL,MACRI,EAAYP,EAAKG,KAAL,UAGoB,IAAhCX,EAAUgB,WAAWC,QACvBL,EAAQM,SAAQ,SAACC,EAAgBC,GAC/B,IAAIC,EAAOrB,EAAUJ,YAAYF,SAASG,cAAc,QAGxD,GAFAwB,EAAKpB,UAAUC,IAAI,QAEfW,EAAO,CACT,IAAIS,EAAYD,EAAKzB,YAAYF,SAASG,cAAc,SACxDyB,EAAUrB,UAAUC,IAAI,QACxBoB,EAAUZ,YAAcG,EAAMO,GAGhCC,EAAKzB,YAAYF,SAASK,eAAeoB,IAErCC,IAAMN,GACRO,EAAKpB,UAAUC,IAAI,YAGrBmB,EAAKE,QAAU,WAIb,IAAIC,EAAWT,GAAaM,EAAKpB,UAAUwB,SAAS,YAEpDzB,EAAU0B,iBAAiB,aAAaR,SAAQ,SAACS,GAC/CA,EAAG1B,UAAU2B,OAAO,eAGlBJ,EAGFrB,IAAU0B,kBAAkB,SAE5B1B,IAAU0B,kBAAkBT,GAC5BC,EAAKpB,UAAUC,IAAI,iBAOvBM,EAAKsB,QACPrC,EAASsC,MAAMC,KAAOxB,EAAKsB,MAAME,KACjCvC,EAASsC,MAAME,MAAQzB,EAAKsB,MAAMI,UAEV,SAApB1B,EAAKsB,MAAMK,KACbzC,SAASC,KAAK+B,iBAAiB,SAASR,SAAQ,SAACS,GAC/CA,EAAG1B,UAAUC,IAAI,WAGnBR,SAASC,KAAK+B,iBAAiB,SAASR,SAAQ,SAACS,GAC/CA,EAAG1B,UAAU2B,OAAO,YAW1BzB,IAAUiC,oBAQZjC,IAAUkC,oBAIVlC,IAAUiC,mB","file":"static/js/main.8d37031a.chunk.js","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\n\nconst labelDiv = document.body.appendChild(document.createElement(\"label\"))\nconst label = labelDiv.appendChild(document.createTextNode(\"\"))\nconst container = document.body.appendChild(document.createElement(\"div\"))\ncontainer.classList.add(\"container\")\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  label.textContent = data.args[\"label\"]\n  let options = data.args[\"options\"]\n  let icons = data.args[\"icons\"]\n  let index = data.args[\"index\"]\n  let clearable = data.args[\"clearable\"]\n  // console.log(captions)\n\n  if (container.childNodes.length === 0) {\n    options.forEach((option: string, i: number) => {\n      let pill = container.appendChild(document.createElement(\"div\"))\n      pill.classList.add(\"pill\")\n\n      if (icons) {\n        let icon_span = pill.appendChild(document.createElement(\"span\"))\n        icon_span.classList.add(\"icon\")\n        icon_span.textContent = icons[i]\n      }\n\n      pill.appendChild(document.createTextNode(option))\n\n      if (i === index) {\n        pill.classList.add(\"selected\")\n      }\n\n      pill.onclick = function () {\n        // If the element is clearable, let the user unselect by clicking on the pill\n        // again. I.e. if this pill (which is clicked) was already selected before, we\n        // unselect it later.\n        let unselect = clearable && pill.classList.contains(\"selected\")\n\n        container.querySelectorAll(\".selected\").forEach((el) => {\n          el.classList.remove(\"selected\")\n        })\n\n        if (unselect) {\n          // Need to pass a string here and convert it to None on the Python side.\n          // If setting null, the components lib returns the \"default\" value (=index).\n          Streamlit.setComponentValue(\"None\")\n        } else {\n          Streamlit.setComponentValue(i)\n          pill.classList.add(\"selected\")\n        }\n      }\n    })\n  }\n\n  // Style according to the app theme.\n  if (data.theme) {\n    labelDiv.style.font = data.theme.font\n    labelDiv.style.color = data.theme.textColor\n    // TODO: Update this with correct classes.\n    if (data.theme.base === \"dark\") {\n      document.body.querySelectorAll(\".pill\").forEach((el) => {\n        el.classList.add(\"dark\")\n      })\n    } else {\n      document.body.querySelectorAll(\".pill\").forEach((el) => {\n        el.classList.remove(\"dark\")\n      })\n    }\n\n    // TODO: Gray out the component and disable click if it's disabled.\n  }\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}